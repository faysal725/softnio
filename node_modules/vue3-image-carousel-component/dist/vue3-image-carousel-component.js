import { defineComponent as xt, h as nt, ref as Ht, computed as Rt, openBlock as ot, createElementBlock as rt, normalizeStyle as H, createElementVNode as R, createVNode as it, unref as st } from "vue";
const j = /^[a-z0-9]+(-[a-z0-9]+)*$/, _ = (t, e, n, r = "") => {
  const o = t.split(":");
  if (t.slice(0, 1) === "@") {
    if (o.length < 2 || o.length > 3)
      return null;
    r = o.shift().slice(1);
  }
  if (o.length > 3 || !o.length)
    return null;
  if (o.length > 1) {
    const c = o.pop(), l = o.pop(), a = {
      // Allow provider without '@': "provider:prefix:name"
      provider: o.length > 0 ? o[0] : r,
      prefix: l,
      name: c
    };
    return e && !F(a) ? null : a;
  }
  const i = o[0], s = i.split("-");
  if (s.length > 1) {
    const c = {
      provider: r,
      prefix: s.shift(),
      name: s.join("-")
    };
    return e && !F(c) ? null : c;
  }
  if (n && r === "") {
    const c = {
      provider: r,
      prefix: "",
      name: i
    };
    return e && !F(c, n) ? null : c;
  }
  return null;
}, F = (t, e) => t ? !!((t.provider === "" || t.provider.match(j)) && (e && t.prefix === "" || t.prefix.match(j)) && t.name.match(j)) : !1, St = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), A = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), D = Object.freeze({
  ...St,
  ...A
}), W = Object.freeze({
  ...D,
  body: "",
  hidden: !1
});
function Vt(t, e) {
  const n = {};
  !t.hFlip != !e.hFlip && (n.hFlip = !0), !t.vFlip != !e.vFlip && (n.vFlip = !0);
  const r = ((t.rotate || 0) + (e.rotate || 0)) % 4;
  return r && (n.rotate = r), n;
}
function ct(t, e) {
  const n = Vt(t, e);
  for (const r in W)
    r in A ? r in t && !(r in n) && (n[r] = A[r]) : r in e ? n[r] = e[r] : r in t && (n[r] = t[r]);
  return n;
}
function zt(t, e) {
  const n = t.icons, r = t.aliases || /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  function i(s) {
    if (n[s])
      return o[s] = [];
    if (!(s in o)) {
      o[s] = null;
      const c = r[s] && r[s].parent, l = c && i(c);
      l && (o[s] = [c].concat(l));
    }
    return o[s];
  }
  return (e || Object.keys(n).concat(Object.keys(r))).forEach(i), o;
}
function Wt(t, e, n) {
  const r = t.icons, o = t.aliases || /* @__PURE__ */ Object.create(null);
  let i = {};
  function s(c) {
    i = ct(
      r[c] || o[c],
      i
    );
  }
  return s(e), n.forEach(s), ct(t, i);
}
function Ct(t, e) {
  const n = [];
  if (typeof t != "object" || typeof t.icons != "object")
    return n;
  t.not_found instanceof Array && t.not_found.forEach((o) => {
    e(o, null), n.push(o);
  });
  const r = zt(t);
  for (const o in r) {
    const i = r[o];
    i && (e(o, Wt(t, o, i)), n.push(o));
  }
  return n;
}
const Qt = {
  provider: "",
  aliases: {},
  not_found: {},
  ...St
};
function V(t, e) {
  for (const n in e)
    if (n in t && typeof t[n] != typeof e[n])
      return !1;
  return !0;
}
function kt(t) {
  if (typeof t != "object" || t === null)
    return null;
  const e = t;
  if (typeof e.prefix != "string" || !t.icons || typeof t.icons != "object" || !V(t, Qt))
    return null;
  const n = e.icons;
  for (const o in n) {
    const i = n[o];
    if (!o.match(j) || typeof i.body != "string" || !V(
      i,
      W
    ))
      return null;
  }
  const r = e.aliases || /* @__PURE__ */ Object.create(null);
  for (const o in r) {
    const i = r[o], s = i.parent;
    if (!o.match(j) || typeof s != "string" || !n[s] && !r[s] || !V(
      i,
      W
    ))
      return null;
  }
  return e;
}
const lt = /* @__PURE__ */ Object.create(null);
function $t(t, e) {
  return {
    provider: t,
    prefix: e,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function S(t, e) {
  const n = lt[t] || (lt[t] = /* @__PURE__ */ Object.create(null));
  return n[e] || (n[e] = $t(t, e));
}
function J(t, e) {
  return kt(e) ? Ct(e, (n, r) => {
    r ? t.icons[n] = r : t.missing.add(n);
  }) : [];
}
function qt(t, e, n) {
  try {
    if (typeof n.body == "string")
      return t.icons[e] = { ...n }, !0;
  } catch {
  }
  return !1;
}
let T = !1;
function jt(t) {
  return typeof t == "boolean" && (T = t), T;
}
function Ut(t) {
  const e = typeof t == "string" ? _(t, !0, T) : t;
  if (e) {
    const n = S(e.provider, e.prefix), r = e.name;
    return n.icons[r] || (n.missing.has(r) ? null : void 0);
  }
}
function Kt(t, e) {
  const n = _(t, !0, T);
  if (!n)
    return !1;
  const r = S(n.provider, n.prefix);
  return qt(r, n.name, e);
}
function Gt(t, e) {
  if (typeof t != "object")
    return !1;
  if (typeof e != "string" && (e = t.provider || ""), T && !e && !t.prefix) {
    let o = !1;
    return kt(t) && (t.prefix = "", Ct(t, (i, s) => {
      s && Kt(i, s) && (o = !0);
    })), o;
  }
  const n = t.prefix;
  if (!F({
    provider: e,
    prefix: n,
    name: "a"
  }))
    return !1;
  const r = S(e, n);
  return !!J(r, t);
}
const Tt = Object.freeze({
  width: null,
  height: null
}), Et = Object.freeze({
  // Dimensions
  ...Tt,
  // Transformations
  ...A
}), Jt = /(-?[0-9.]*[0-9]+[0-9.]*)/g, Xt = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function at(t, e, n) {
  if (e === 1)
    return t;
  if (n = n || 100, typeof t == "number")
    return Math.ceil(t * e * n) / n;
  if (typeof t != "string")
    return t;
  const r = t.split(Jt);
  if (r === null || !r.length)
    return t;
  const o = [];
  let i = r.shift(), s = Xt.test(i);
  for (; ; ) {
    if (s) {
      const c = parseFloat(i);
      isNaN(c) ? o.push(i) : o.push(Math.ceil(c * e * n) / n);
    } else
      o.push(i);
    if (i = r.shift(), i === void 0)
      return o.join("");
    s = !s;
  }
}
const Yt = (t) => t === "unset" || t === "undefined" || t === "none";
function Zt(t, e) {
  const n = {
    ...D,
    ...t
  }, r = {
    ...Et,
    ...e
  }, o = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let i = n.body;
  [n, r].forEach((w) => {
    const h = [], f = w.hFlip, I = w.vFlip;
    let y = w.rotate;
    f ? I ? y += 2 : (h.push(
      "translate(" + (o.width + o.left).toString() + " " + (0 - o.top).toString() + ")"
    ), h.push("scale(-1 1)"), o.top = o.left = 0) : I && (h.push(
      "translate(" + (0 - o.left).toString() + " " + (o.height + o.top).toString() + ")"
    ), h.push("scale(1 -1)"), o.top = o.left = 0);
    let b;
    switch (y < 0 && (y -= Math.floor(y / 4) * 4), y = y % 4, y) {
      case 1:
        b = o.height / 2 + o.top, h.unshift(
          "rotate(90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
      case 2:
        h.unshift(
          "rotate(180 " + (o.width / 2 + o.left).toString() + " " + (o.height / 2 + o.top).toString() + ")"
        );
        break;
      case 3:
        b = o.width / 2 + o.left, h.unshift(
          "rotate(-90 " + b.toString() + " " + b.toString() + ")"
        );
        break;
    }
    y % 2 === 1 && (o.left !== o.top && (b = o.left, o.left = o.top, o.top = b), o.width !== o.height && (b = o.width, o.width = o.height, o.height = b)), h.length && (i = '<g transform="' + h.join(" ") + '">' + i + "</g>");
  });
  const s = r.width, c = r.height, l = o.width, a = o.height;
  let u, d;
  s === null ? (d = c === null ? "1em" : c === "auto" ? a : c, u = at(d, l / a)) : (u = s === "auto" ? l : s, d = c === null ? at(u, a / l) : c === "auto" ? a : c);
  const g = {}, m = (w, h) => {
    Yt(h) || (g[w] = h.toString());
  };
  return m("width", u), m("height", d), g.viewBox = o.left.toString() + " " + o.top.toString() + " " + l.toString() + " " + a.toString(), {
    attributes: g,
    body: i
  };
}
const te = /\sid="(\S+)"/g, ee = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let ne = 0;
function oe(t, e = ee) {
  const n = [];
  let r;
  for (; r = te.exec(t); )
    n.push(r[1]);
  if (!n.length)
    return t;
  const o = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((i) => {
    const s = typeof e == "function" ? e(i) : e + (ne++).toString(), c = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    t = t.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + c + ')([")]|\\.[a-z])', "g"),
      "$1" + s + o + "$3"
    );
  }), t = t.replace(new RegExp(o, "g"), ""), t;
}
const Q = /* @__PURE__ */ Object.create(null);
function re(t, e) {
  Q[t] = e;
}
function $(t) {
  return Q[t] || Q[""];
}
function X(t) {
  let e;
  if (typeof t.resources == "string")
    e = [t.resources];
  else if (e = t.resources, !(e instanceof Array) || !e.length)
    return null;
  return {
    // API hosts
    resources: e,
    // Root path
    path: t.path || "/",
    // URL length limit
    maxURL: t.maxURL || 500,
    // Timeout before next host is used.
    rotate: t.rotate || 750,
    // Timeout before failing query.
    timeout: t.timeout || 5e3,
    // Randomise default API end point.
    random: t.random === !0,
    // Start index
    index: t.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: t.dataAfterTimeout !== !1
  };
}
const Y = /* @__PURE__ */ Object.create(null), k = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], L = [];
for (; k.length > 0; )
  k.length === 1 || Math.random() > 0.5 ? L.push(k.shift()) : L.push(k.pop());
Y[""] = X({
  resources: ["https://api.iconify.design"].concat(L)
});
function ie(t, e) {
  const n = X(e);
  return n === null ? !1 : (Y[t] = n, !0);
}
function Z(t) {
  return Y[t];
}
const se = () => {
  let t;
  try {
    if (t = fetch, typeof t == "function")
      return t;
  } catch {
  }
};
let ut = se();
function ce(t, e) {
  const n = Z(t);
  if (!n)
    return 0;
  let r;
  if (!n.maxURL)
    r = 0;
  else {
    let o = 0;
    n.resources.forEach((s) => {
      o = Math.max(o, s.length);
    });
    const i = e + ".json?icons=";
    r = n.maxURL - o - n.path.length - i.length;
  }
  return r;
}
function le(t) {
  return t === 404;
}
const ae = (t, e, n) => {
  const r = [], o = ce(t, e), i = "icons";
  let s = {
    type: i,
    provider: t,
    prefix: e,
    icons: []
  }, c = 0;
  return n.forEach((l, a) => {
    c += l.length + 1, c >= o && a > 0 && (r.push(s), s = {
      type: i,
      provider: t,
      prefix: e,
      icons: []
    }, c = l.length), s.icons.push(l);
  }), r.push(s), r;
};
function ue(t) {
  if (typeof t == "string") {
    const e = Z(t);
    if (e)
      return e.path;
  }
  return "/";
}
const fe = (t, e, n) => {
  if (!ut) {
    n("abort", 424);
    return;
  }
  let r = ue(e.provider);
  switch (e.type) {
    case "icons": {
      const i = e.prefix, c = e.icons.join(","), l = new URLSearchParams({
        icons: c
      });
      r += i + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const i = e.uri;
      r += i.slice(0, 1) === "/" ? i.slice(1) : i;
      break;
    }
    default:
      n("abort", 400);
      return;
  }
  let o = 503;
  ut(t + r).then((i) => {
    const s = i.status;
    if (s !== 200) {
      setTimeout(() => {
        n(le(s) ? "abort" : "next", s);
      });
      return;
    }
    return o = 501, i.json();
  }).then((i) => {
    if (typeof i != "object" || i === null) {
      setTimeout(() => {
        i === 404 ? n("abort", i) : n("next", o);
      });
      return;
    }
    setTimeout(() => {
      n("success", i);
    });
  }).catch(() => {
    n("next", o);
  });
}, de = {
  prepare: ae,
  send: fe
};
function he(t) {
  const e = {
    loaded: [],
    missing: [],
    pending: []
  }, n = /* @__PURE__ */ Object.create(null);
  t.sort((o, i) => o.provider !== i.provider ? o.provider.localeCompare(i.provider) : o.prefix !== i.prefix ? o.prefix.localeCompare(i.prefix) : o.name.localeCompare(i.name));
  let r = {
    provider: "",
    prefix: "",
    name: ""
  };
  return t.forEach((o) => {
    if (r.name === o.name && r.prefix === o.prefix && r.provider === o.provider)
      return;
    r = o;
    const i = o.provider, s = o.prefix, c = o.name, l = n[i] || (n[i] = /* @__PURE__ */ Object.create(null)), a = l[s] || (l[s] = S(i, s));
    let u;
    c in a.icons ? u = e.loaded : s === "" || a.missing.has(c) ? u = e.missing : u = e.pending;
    const d = {
      provider: i,
      prefix: s,
      name: c
    };
    u.push(d);
  }), e;
}
function Pt(t, e) {
  t.forEach((n) => {
    const r = n.loaderCallbacks;
    r && (n.loaderCallbacks = r.filter((o) => o.id !== e));
  });
}
function pe(t) {
  t.pendingCallbacksFlag || (t.pendingCallbacksFlag = !0, setTimeout(() => {
    t.pendingCallbacksFlag = !1;
    const e = t.loaderCallbacks ? t.loaderCallbacks.slice(0) : [];
    if (!e.length)
      return;
    let n = !1;
    const r = t.provider, o = t.prefix;
    e.forEach((i) => {
      const s = i.icons, c = s.pending.length;
      s.pending = s.pending.filter((l) => {
        if (l.prefix !== o)
          return !0;
        const a = l.name;
        if (t.icons[a])
          s.loaded.push({
            provider: r,
            prefix: o,
            name: a
          });
        else if (t.missing.has(a))
          s.missing.push({
            provider: r,
            prefix: o,
            name: a
          });
        else
          return n = !0, !0;
        return !1;
      }), s.pending.length !== c && (n || Pt([t], i.id), i.callback(
        s.loaded.slice(0),
        s.missing.slice(0),
        s.pending.slice(0),
        i.abort
      ));
    });
  }));
}
let ge = 0;
function me(t, e, n) {
  const r = ge++, o = Pt.bind(null, n, r);
  if (!e.pending.length)
    return o;
  const i = {
    id: r,
    icons: e,
    callback: t,
    abort: o
  };
  return n.forEach((s) => {
    (s.loaderCallbacks || (s.loaderCallbacks = [])).push(i);
  }), o;
}
function ye(t, e = !0, n = !1) {
  const r = [];
  return t.forEach((o) => {
    const i = typeof o == "string" ? _(o, e, n) : o;
    i && r.push(i);
  }), r;
}
var be = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function we(t, e, n, r) {
  const o = t.resources.length, i = t.random ? Math.floor(Math.random() * o) : t.index;
  let s;
  if (t.random) {
    let p = t.resources.slice(0);
    for (s = []; p.length > 1; ) {
      const v = Math.floor(Math.random() * p.length);
      s.push(p[v]), p = p.slice(0, v).concat(p.slice(v + 1));
    }
    s = s.concat(p);
  } else
    s = t.resources.slice(i).concat(t.resources.slice(0, i));
  const c = Date.now();
  let l = "pending", a = 0, u, d = null, g = [], m = [];
  typeof r == "function" && m.push(r);
  function w() {
    d && (clearTimeout(d), d = null);
  }
  function h() {
    l === "pending" && (l = "aborted"), w(), g.forEach((p) => {
      p.status === "pending" && (p.status = "aborted");
    }), g = [];
  }
  function f(p, v) {
    v && (m = []), typeof p == "function" && m.push(p);
  }
  function I() {
    return {
      startTime: c,
      payload: e,
      status: l,
      queriesSent: a,
      queriesPending: g.length,
      subscribe: f,
      abort: h
    };
  }
  function y() {
    l = "failed", m.forEach((p) => {
      p(void 0, u);
    });
  }
  function b() {
    g.forEach((p) => {
      p.status === "pending" && (p.status = "aborted");
    }), g = [];
  }
  function Nt(p, v, C) {
    const P = v !== "success";
    switch (g = g.filter((x) => x !== p), l) {
      case "pending":
        break;
      case "failed":
        if (P || !t.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (v === "abort") {
      u = C, y();
      return;
    }
    if (P) {
      u = C, g.length || (s.length ? N() : y());
      return;
    }
    if (w(), b(), !t.random) {
      const x = t.resources.indexOf(p.resource);
      x !== -1 && x !== t.index && (t.index = x);
    }
    l = "completed", m.forEach((x) => {
      x(C);
    });
  }
  function N() {
    if (l !== "pending")
      return;
    w();
    const p = s.shift();
    if (p === void 0) {
      if (g.length) {
        d = setTimeout(() => {
          w(), l === "pending" && (b(), y());
        }, t.timeout);
        return;
      }
      y();
      return;
    }
    const v = {
      status: "pending",
      resource: p,
      callback: (C, P) => {
        Nt(v, C, P);
      }
    };
    g.push(v), a++, d = setTimeout(N, t.rotate), n(p, e, v.callback);
  }
  return setTimeout(N), I;
}
function Mt(t) {
  const e = {
    ...be,
    ...t
  };
  let n = [];
  function r() {
    n = n.filter((c) => c().status === "pending");
  }
  function o(c, l, a) {
    const u = we(
      e,
      c,
      l,
      (d, g) => {
        r(), a && a(d, g);
      }
    );
    return n.push(u), u;
  }
  function i(c) {
    return n.find((l) => c(l)) || null;
  }
  return {
    query: o,
    find: i,
    setIndex: (c) => {
      e.index = c;
    },
    getIndex: () => e.index,
    cleanup: r
  };
}
function ft() {
}
const z = /* @__PURE__ */ Object.create(null);
function ve(t) {
  if (!z[t]) {
    const e = Z(t);
    if (!e)
      return;
    const n = Mt(e), r = {
      config: e,
      redundancy: n
    };
    z[t] = r;
  }
  return z[t];
}
function Ie(t, e, n) {
  let r, o;
  if (typeof t == "string") {
    const i = $(t);
    if (!i)
      return n(void 0, 424), ft;
    o = i.send;
    const s = ve(t);
    s && (r = s.redundancy);
  } else {
    const i = X(t);
    if (i) {
      r = Mt(i);
      const s = t.resources ? t.resources[0] : "", c = $(s);
      c && (o = c.send);
    }
  }
  return !r || !o ? (n(void 0, 424), ft) : r.query(e, o, n)().abort;
}
const dt = "iconify2", E = "iconify", Ft = E + "-count", ht = E + "-version", Lt = 36e5, xe = 168;
function q(t, e) {
  try {
    return t.getItem(e);
  } catch {
  }
}
function tt(t, e, n) {
  try {
    return t.setItem(e, n), !0;
  } catch {
  }
}
function pt(t, e) {
  try {
    t.removeItem(e);
  } catch {
  }
}
function U(t, e) {
  return tt(t, Ft, e.toString());
}
function K(t) {
  return parseInt(q(t, Ft)) || 0;
}
const B = {
  local: !0,
  session: !0
}, Ot = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let et = !1;
function Se(t) {
  et = t;
}
let M = typeof window > "u" ? {} : window;
function At(t) {
  const e = t + "Storage";
  try {
    if (M && M[e] && typeof M[e].length == "number")
      return M[e];
  } catch {
  }
  B[t] = !1;
}
function _t(t, e) {
  const n = At(t);
  if (!n)
    return;
  const r = q(n, ht);
  if (r !== dt) {
    if (r) {
      const c = K(n);
      for (let l = 0; l < c; l++)
        pt(n, E + l.toString());
    }
    tt(n, ht, dt), U(n, 0);
    return;
  }
  const o = Math.floor(Date.now() / Lt) - xe, i = (c) => {
    const l = E + c.toString(), a = q(n, l);
    if (typeof a == "string") {
      try {
        const u = JSON.parse(a);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > o && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        e(u, c))
          return !0;
      } catch {
      }
      pt(n, l);
    }
  };
  let s = K(n);
  for (let c = s - 1; c >= 0; c--)
    i(c) || (c === s - 1 ? (s--, U(n, s)) : Ot[t].add(c));
}
function Dt() {
  if (!et) {
    Se(!0);
    for (const t in B)
      _t(t, (e) => {
        const n = e.data, r = e.provider, o = n.prefix, i = S(
          r,
          o
        );
        if (!J(i, n).length)
          return !1;
        const s = n.lastModified || -1;
        return i.lastModifiedCached = i.lastModifiedCached ? Math.min(i.lastModifiedCached, s) : s, !0;
      });
  }
}
function Ce(t, e) {
  const n = t.lastModifiedCached;
  if (
    // Matches or newer
    n && n >= e
  )
    return n === e;
  if (t.lastModifiedCached = e, n)
    for (const r in B)
      _t(r, (o) => {
        const i = o.data;
        return o.provider !== t.provider || i.prefix !== t.prefix || i.lastModified === e;
      });
  return !0;
}
function ke(t, e) {
  et || Dt();
  function n(r) {
    let o;
    if (!B[r] || !(o = At(r)))
      return;
    const i = Ot[r];
    let s;
    if (i.size)
      i.delete(s = Array.from(i).shift());
    else if (s = K(o), !U(o, s + 1))
      return;
    const c = {
      cached: Math.floor(Date.now() / Lt),
      provider: t.provider,
      data: e
    };
    return tt(
      o,
      E + s.toString(),
      JSON.stringify(c)
    );
  }
  e.lastModified && !Ce(t, e.lastModified) || Object.keys(e.icons).length && (e.not_found && (e = Object.assign({}, e), delete e.not_found), n("local") || n("session"));
}
function gt() {
}
function je(t) {
  t.iconsLoaderFlag || (t.iconsLoaderFlag = !0, setTimeout(() => {
    t.iconsLoaderFlag = !1, pe(t);
  }));
}
function Te(t, e) {
  t.iconsToLoad ? t.iconsToLoad = t.iconsToLoad.concat(e).sort() : t.iconsToLoad = e, t.iconsQueueFlag || (t.iconsQueueFlag = !0, setTimeout(() => {
    t.iconsQueueFlag = !1;
    const { provider: n, prefix: r } = t, o = t.iconsToLoad;
    delete t.iconsToLoad;
    let i;
    if (!o || !(i = $(n)))
      return;
    i.prepare(n, r, o).forEach((c) => {
      Ie(n, c, (l) => {
        if (typeof l != "object")
          c.icons.forEach((a) => {
            t.missing.add(a);
          });
        else
          try {
            const a = J(
              t,
              l
            );
            if (!a.length)
              return;
            const u = t.pendingIcons;
            u && a.forEach((d) => {
              u.delete(d);
            }), ke(t, l);
          } catch (a) {
            console.error(a);
          }
        je(t);
      });
    });
  }));
}
const Ee = (t, e) => {
  const n = ye(t, !0, jt()), r = he(n);
  if (!r.pending.length) {
    let l = !0;
    return e && setTimeout(() => {
      l && e(
        r.loaded,
        r.missing,
        r.pending,
        gt
      );
    }), () => {
      l = !1;
    };
  }
  const o = /* @__PURE__ */ Object.create(null), i = [];
  let s, c;
  return r.pending.forEach((l) => {
    const { provider: a, prefix: u } = l;
    if (u === c && a === s)
      return;
    s = a, c = u, i.push(S(a, u));
    const d = o[a] || (o[a] = /* @__PURE__ */ Object.create(null));
    d[u] || (d[u] = []);
  }), r.pending.forEach((l) => {
    const { provider: a, prefix: u, name: d } = l, g = S(a, u), m = g.pendingIcons || (g.pendingIcons = /* @__PURE__ */ new Set());
    m.has(d) || (m.add(d), o[a][u].push(d));
  }), i.forEach((l) => {
    const { provider: a, prefix: u } = l;
    o[a][u].length && Te(l, o[a][u]);
  }), e ? me(e, r, i) : gt;
};
function Pe(t, e) {
  const n = {
    ...t
  };
  for (const r in e) {
    const o = e[r], i = typeof o;
    r in Tt ? (o === null || o && (i === "string" || i === "number")) && (n[r] = o) : i === typeof n[r] && (n[r] = r === "rotate" ? o % 4 : o);
  }
  return n;
}
const Me = /[\s,]+/;
function Fe(t, e) {
  e.split(Me).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        t.hFlip = !0;
        break;
      case "vertical":
        t.vFlip = !0;
        break;
    }
  });
}
function Le(t, e = 0) {
  const n = t.replace(/^-?[0-9.]*/, "");
  function r(o) {
    for (; o < 0; )
      o += 4;
    return o % 4;
  }
  if (n === "") {
    const o = parseInt(t);
    return isNaN(o) ? 0 : r(o);
  } else if (n !== t) {
    let o = 0;
    switch (n) {
      case "%":
        o = 25;
        break;
      case "deg":
        o = 90;
    }
    if (o) {
      let i = parseFloat(t.slice(0, t.length - n.length));
      return isNaN(i) ? 0 : (i = i / o, i % 1 === 0 ? r(i) : 0);
    }
  }
  return e;
}
function Oe(t, e) {
  let n = t.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const r in e)
    n += " " + r + '="' + e[r] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + t + "</svg>";
}
function Ae(t) {
  return t.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function _e(t) {
  return "data:image/svg+xml," + Ae(t);
}
function De(t) {
  return 'url("' + _e(t) + '")';
}
const mt = {
  ...Et,
  inline: !1
}, Be = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, Ne = {
  display: "inline-block"
}, G = {
  backgroundColor: "currentColor"
}, Bt = {
  backgroundColor: "transparent"
}, yt = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, bt = {
  webkitMask: G,
  mask: G,
  background: Bt
};
for (const t in bt) {
  const e = bt[t];
  for (const n in yt)
    e[t + n] = yt[n];
}
const O = {};
["horizontal", "vertical"].forEach((t) => {
  const e = t.slice(0, 1) + "Flip";
  O[t + "-flip"] = e, O[t.slice(0, 1) + "-flip"] = e, O[t + "Flip"] = e;
});
function wt(t) {
  return t + (t.match(/^[-0-9.]+$/) ? "px" : "");
}
const vt = (t, e) => {
  const n = Pe(mt, e), r = { ...Be }, o = e.mode || "svg", i = {}, s = e.style, c = typeof s == "object" && !(s instanceof Array) ? s : {};
  for (let h in e) {
    const f = e[h];
    if (f !== void 0)
      switch (h) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          n[h] = f === !0 || f === "true" || f === 1;
          break;
        case "flip":
          typeof f == "string" && Fe(n, f);
          break;
        case "color":
          i.color = f;
          break;
        case "rotate":
          typeof f == "string" ? n[h] = Le(f) : typeof f == "number" && (n[h] = f);
          break;
        case "ariaHidden":
        case "aria-hidden":
          f !== !0 && f !== "true" && delete r["aria-hidden"];
          break;
        default: {
          const I = O[h];
          I ? (f === !0 || f === "true" || f === 1) && (n[I] = !0) : mt[h] === void 0 && (r[h] = f);
        }
      }
  }
  const l = Zt(t, n), a = l.attributes;
  if (n.inline && (i.verticalAlign = "-0.125em"), o === "svg") {
    r.style = {
      ...i,
      ...c
    }, Object.assign(r, a);
    let h = 0, f = e.id;
    return typeof f == "string" && (f = f.replace(/-/g, "_")), r.innerHTML = oe(l.body, f ? () => f + "ID" + h++ : "iconifyVue"), nt("svg", r);
  }
  const { body: u, width: d, height: g } = t, m = o === "mask" || (o === "bg" ? !1 : u.indexOf("currentColor") !== -1), w = Oe(u, {
    ...a,
    width: d + "",
    height: g + ""
  });
  return r.style = {
    ...i,
    "--svg": De(w),
    width: wt(a.width),
    height: wt(a.height),
    ...Ne,
    ...m ? G : Bt,
    ...c
  }, nt("span", r);
};
jt(!0);
re("", de);
if (typeof document < "u" && typeof window < "u") {
  Dt();
  const t = window;
  if (t.IconifyPreload !== void 0) {
    const e = t.IconifyPreload, n = "Invalid IconifyPreload syntax.";
    typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((r) => {
      try {
        // Check if item is an object and not null/array
        (typeof r != "object" || r === null || r instanceof Array || // Check for 'icons' and 'prefix'
        typeof r.icons != "object" || typeof r.prefix != "string" || // Add icon set
        !Gt(r)) && console.error(n);
      } catch {
        console.error(n);
      }
    });
  }
  if (t.IconifyProviders !== void 0) {
    const e = t.IconifyProviders;
    if (typeof e == "object" && e !== null)
      for (let n in e) {
        const r = "IconifyProviders[" + n + "] is invalid.";
        try {
          const o = e[n];
          if (typeof o != "object" || !o || o.resources === void 0)
            continue;
          ie(n, o) || console.error(r);
        } catch {
          console.error(r);
        }
      }
  }
}
const He = {
  ...D,
  body: ""
}, It = xt({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: !1,
  // Set initial data
  data() {
    return {
      // Mounted status
      iconMounted: !1,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this._name = "", this._loadingIcon = null, this.iconMounted = !0;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      this._loadingIcon && (this._loadingIcon.abort(), this._loadingIcon = null);
    },
    // Get data for icon to render or null
    getIcon(t, e) {
      if (typeof t == "object" && t !== null && typeof t.body == "string")
        return this._name = "", this.abortLoading(), {
          data: t
        };
      let n;
      if (typeof t != "string" || (n = _(t, !1, !0)) === null)
        return this.abortLoading(), null;
      const r = Ut(n);
      if (!r)
        return (!this._loadingIcon || this._loadingIcon.name !== t) && (this.abortLoading(), this._name = "", r !== null && (this._loadingIcon = {
          name: t,
          abort: Ee([n], () => {
            this.counter++;
          })
        })), null;
      this.abortLoading(), this._name !== t && (this._name = t, e && e(t));
      const o = ["iconify"];
      return n.prefix !== "" && o.push("iconify--" + n.prefix), n.provider !== "" && o.push("iconify--" + n.provider), { data: r, classes: o };
    }
  },
  // Render icon
  render() {
    this.counter;
    const t = this.$attrs, e = this.iconMounted ? this.getIcon(t.icon, t.onLoad) : null;
    if (!e)
      return vt(He, t);
    let n = t;
    return e.classes && (n = {
      ...t,
      class: (typeof t.class == "string" ? t.class + " " : "") + e.classes.join(" ")
    }), vt({
      ...D,
      ...e.data
    }, n);
  }
}), Re = ["src", "object-fit"], Ve = /* @__PURE__ */ xt({
  __name: "V-Carousel",
  props: {
    images: {},
    backButtonWidth: {},
    nextButtonWidth: {},
    backButtonHeight: {},
    nextButtonHeight: {},
    arrowsColor: {},
    slideWidth: {},
    slideHeight: {},
    mainDivDisplay: {},
    mainDivAlignItems: {},
    imageWidth: {},
    imageHeight: {},
    objectFitCover: {}
  },
  setup(t) {
    const e = t, n = Ht(0), r = Rt(() => e.images ? e.images[n.value] : "");
    function o() {
      n.value = (n.value + 1) % (e.images ? e.images.length : 0);
    }
    function i() {
      n.value = (n.value - 1 + (e.images ? e.images.length : 0)) % (e.images ? e.images.length : 0);
    }
    return (s, c) => (ot(), rt("div", {
      class: "carousel",
      style: H([{
        display: s.mainDivDisplay || "flex",
        "align-items": s.mainDivAlignItems || "center"
      }])
    }, [
      R("button", { onClick: i }, [
        it(st(It), {
          icon: "ep:arrow-left-bold",
          width: s.backButtonWidth || "48",
          height: s.backButtonHeight || "48",
          color: s.arrowsColor || "black"
        }, null, 8, ["width", "height", "color"])
      ]),
      R("div", {
        class: "slide-container",
        style: H([{
          width: s.slideWidth || "500px",
          height: s.slideHeight || "auto"
        }])
      }, [
        (ot(), rt("img", {
          src: r.value,
          key: r.value,
          class: "slide",
          "object-fit": s.objectFitCover || "cover",
          style: H([{
            width: s.imageWidth || "100%",
            height: s.imageHeight || "100%"
          }])
        }, null, 12, Re))
      ], 4),
      R("button", { onClick: o }, [
        it(st(It), {
          icon: "ep:arrow-right-bold",
          width: s.nextButtonWidth || "48",
          color: s.arrowsColor || "black",
          height: s.nextButtonHeight || "48"
        }, null, 8, ["width", "color", "height"])
      ])
    ], 4));
  }
});
const ze = (t, e) => {
  const n = t.__vccOpts || t;
  for (const [r, o] of e)
    n[r] = o;
  return n;
}, Qe = /* @__PURE__ */ ze(Ve, [["__scopeId", "data-v-b17753b1"]]);
export {
  Qe as VCarousel
};
